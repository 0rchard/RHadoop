<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>What&#39;s new in 1.4</title>

<base target="_blank"/>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

pre code {
   display: block; padding: 0.5em;
}

code.r {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>





</head>

<body>
<h1>What&#39;s new in 1.4</h1>

<h2>More consistency and control when dealing with structured data</h2>

<p>We 1.3 we started adding more support for dealing with structured data, albeit not the main focus of that release. But we heard from many users that they deal with structured data 99.9% of the time and they would much rather code with matrices and data frames than nested lists. So with 1.4 we made an effort to review all the step of the &ldquo;structured&rdquo; data path.</p>

<ol>
<li><em>Process medium size data chunks by default</em>. <code>to dfs</code> will store matrices and data frames after splitting them into smaller  matrices and data frames, not individial rows. They are easier to put back together, keep more of their metadata and promote   more efficient R programming. This is my favorite example.</li>
</ol>

<pre><code>from.dfs(mapreduce(to.dfs(M), 
  map = function (k,Mi) keyval(NULL, t(Mi)%*%Mi), 
  reduce = function(k,XX) keyval(NULL, Reduce(&#39;+&#39;, XX)), combine = T))[[1]]$val
</code></pre>

<p>Short and to the point, and even efficient! If you pass a key-value list to to.dfs, then it will just store one element of the list per record. You are in charge. For any other list, the result is the same but with the key set to NULL.</p>

<ol>
<li><em>No heuristic guesses</em>: this is a foundational package to enable R development on Hadoop. In the tension between supporting interactive use or programming we need to err in favor of programming. So for instance <code>rmr</code> used to drop keys when returning results in structured format when all keys were <code>NULL</code>. Now it always returns a key value pair, either or both of which can be NULL at times. When programming, you need to minimize corner cases and anticipate them and dropping the key portion of the return value vased on the data was asking for trouble. I am not saying that interactive use is bad, but not the main concern in rmr. </li>
<li><em>Don&#39;t coerce the data</em>: when you choose the structured option we try to put the data back together as it was, not to force it to a data frame as before (and the old <code>to.data.frame</code> and <code>reduce.on.data.frame</code> options are gone for that reason). Given a key value list, the conversion acts seprately on the keys and the values. When dealing with matrices and data frames, it will try to <code>rbind</code> them together, otherwise just <code>unlist</code> or concatenate them depending wether they are atomic or not. This represents a change of behavior in several ways: 

<ol>
<li>if all values are atomic vectors, they are concatenated, not rbinded to form a matrix and then coerced to data frame. If you want the old behavior, coerce the individual vectors to a matrix with a single row;</li>
<li>matrices are rbinded to a larger matrix, no data frame conversion</li>
<li>factors are concatenated as factors</li>
</ol></li>
</ol>

</body>

</html>

